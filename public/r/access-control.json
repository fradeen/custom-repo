{
	"$schema": "https://ui.shadcn.com/schema/registry-item.json",
	"name": "access-control",
	"title": "Attribute Based Access Control",
	"description": "Attribute based access controll system",
	"files": [
		{
			"path": "src/registry/lib/auth/abac.ts",
			"content": "import { evaluateConditionTree } from \"@/registry/lib/auth/condition-tree-eval\";\nimport type { ConditionTree } from \"@/registry/lib/auth/types/condition-tree\";\nimport type { BaseResource } from \"@/registry/lib/auth/types/resource\";\nimport type { BaseSubject } from \"@/registry/lib/auth/types/subject\";\n\ntype AccessControlConfig<\n\tS extends BaseSubject,\n\tActions extends Readonly<Array<string>>,\n\tResourceMap extends { [K in keyof ResourceMap]: BaseResource<K & string> },\n> = {\n\tactions: Readonly<Array<string>>;\n\tgetConditions: (\n\t\tsubject: S,\n\t\tresource: ResourceMap[keyof ResourceMap][\"type\"],\n\t\taction: Actions[number],\n\t\tRequiresResource: boolean,\n\t) => Promise<ConditionTree<S, ResourceMap[keyof ResourceMap], boolean>[]>;\n};\ntype ActionMethodMap<\n\tActions extends Readonly<Array<string>>,\n\tResourceMap extends { [K in keyof ResourceMap]: BaseResource<K & string> },\n> = {\n\t[A in Actions[number]]: (\n\t\targ:\n\t\t\t| ResourceMap[keyof ResourceMap]\n\t\t\t| ResourceMap[keyof ResourceMap][\"type\"],\n\t) => Promise<boolean>;\n};\nexport class AccessControl<\n\tS extends BaseSubject,\n\tActions extends Readonly<Array<string>>,\n\tResourceMap extends { [K in keyof ResourceMap]: BaseResource<K & string> },\n> {\n\t#config: AccessControlConfig<S, Actions, ResourceMap>;\n\tasync #checkAccess(\n\t\tsubject: S,\n\t\taction: Actions[number],\n\t\tresource:\n\t\t\t| ResourceMap[keyof ResourceMap]\n\t\t\t| ResourceMap[keyof ResourceMap][\"type\"],\n\t): Promise<boolean> {\n\t\tconst resourceType =\n\t\t\ttypeof resource === \"string\" ? resource : resource.type;\n\t\tconst conditions = await this.#config.getConditions(\n\t\t\tsubject,\n\t\t\tresourceType,\n\t\t\taction,\n\t\t\t!(typeof resource === \"string\"),\n\t\t);\n\t\tconsole.info(\"conditions for authorization:\", conditions);\n\t\tif (!conditions.length)\n\t\t\tconsole.error(\"No conditions/policies found for role-resource combo.\");\n\t\treturn conditions.some((condition) => {\n\t\t\tif (typeof resource === \"string\")\n\t\t\t\treturn evaluateConditionTree(condition, { subject: subject });\n\t\t\telse\n\t\t\t\treturn evaluateConditionTree(condition, {\n\t\t\t\t\tsubject: subject,\n\t\t\t\t\tresource: resource,\n\t\t\t\t});\n\t\t});\n\t}\n\tconstructor(config: AccessControlConfig<S, Actions, ResourceMap>) {\n\t\tthis.#config = config;\n\t}\n\n\tcan(subject: S): {\n\t\t[A in Actions[number]]: (\n\t\t\targ:\n\t\t\t\t| ResourceMap[keyof ResourceMap]\n\t\t\t\t| ResourceMap[keyof ResourceMap][\"type\"],\n\t\t) => Promise<boolean>;\n\t} {\n\t\tconst api: ActionMethodMap<Actions, ResourceMap> = {} as ActionMethodMap<\n\t\t\tActions,\n\t\t\tResourceMap\n\t\t>;\n\n\t\tfor (const action of this.#config.actions) {\n\t\t\tapi[action as Actions[number]] = (arg) =>\n\t\t\t\tthis.#checkAccess(subject, action, arg);\n\t\t}\n\t\treturn Object.freeze(api);\n\t}\n}\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/condition-tree-eval.ts",
			"content": "import type { ConditionTree } from \"@/registry/lib/auth/types/condition-tree\";\nimport type { AuthContext } from \"@/registry/lib/auth/types/policy\";\nimport type { BaseResource } from \"@/registry/lib/auth/types/resource\";\nimport type { BaseSubject } from \"@/registry/lib/auth/types/subject\";\n\nfunction getValueByPath<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n>(ctx: AuthContext<S, Resource, RequiresResource>, path: string): unknown {\n\treturn path.split(\".\").reduce<unknown>((acc, key) => {\n\t\tif (acc && typeof acc === \"object\" && !Array.isArray(acc)) {\n\t\t\treturn (acc as Record<string, unknown>)[key];\n\t\t}\n\t\treturn undefined;\n\t}, ctx);\n}\n\nfunction coerceTypes(\n\tl: unknown,\n\tr: unknown,\n): [number, number] | [boolean, boolean] | [string, string] {\n\tif (!Number.isNaN(Number(l)) && !Number.isNaN(Number(r)))\n\t\treturn [Number(l), Number(r)];\n\tif (typeof l === \"boolean\" || typeof r === \"boolean\")\n\t\treturn [Boolean(l), Boolean(r)];\n\treturn [l, r] as [string, string];\n}\n\nexport function evaluateConditionTree<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n>(\n\ttree: ConditionTree<S, Resource, RequiresResource>,\n\tctx: AuthContext<S, Resource, RequiresResource>,\n): boolean {\n\t// Group node\n\tif (\"join\" in tree) {\n\t\treturn tree.join === \"and\"\n\t\t\t? tree.conditions.every((c) => evaluateConditionTree(c, ctx))\n\t\t\t: tree.conditions.some((c) => evaluateConditionTree(c, ctx));\n\t}\n\n\t// Leaf node\n\tconst lRaw = getValueByPath(ctx, tree.left);\n\n\tconst rRaw =\n\t\ttypeof tree.right === \"string\" &&\n\t\t(tree.right.startsWith(\"subject.\") ||\n\t\t\t(tree.right.startsWith(\"resource.\") && \"resource\" in ctx))\n\t\t\t? getValueByPath(ctx, tree.right)\n\t\t\t: tree.right;\n\n\tconst [l, r] = coerceTypes(lRaw, rRaw);\n\n\tswitch (tree.op) {\n\t\tcase \"eq\":\n\t\t\treturn l === r;\n\t\tcase \"neq\":\n\t\t\treturn l !== r;\n\t\tcase \"gt\":\n\t\t\treturn (l as number) > (r as number);\n\t\tcase \"lt\":\n\t\t\treturn (l as number) < (r as number);\n\t\tcase \"gte\":\n\t\t\treturn (l as number) >= (r as number);\n\t\tcase \"lte\":\n\t\t\treturn (l as number) <= (r as number);\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/constant.ts",
			"content": "export const OPERATORS = [\"eq\", \"neq\", \"gt\", \"lt\", \"gte\", \"lte\"] as const;\nexport type Operator = (typeof OPERATORS)[number];\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/condition-tree.ts",
			"content": "import type { Operator } from \"@/registry/lib/auth/constant\";\nimport type { AuthContext } from \"@/registry/lib/auth/types/policy\";\nimport type { BaseResource } from \"@/registry/lib/auth/types/resource\";\nimport type { BaseSubject } from \"@/registry/lib/auth/types/subject\";\n\ntype Primitive = string | boolean | number | bigint;\n\ntype DotPathMap<T, Prefix extends string = \"\"> = {\n\t[K in keyof T & string]: T[K] extends Primitive\n\t\t? { path: `${Prefix}${K}`; type: T[K] }\n\t\t: T[K] extends Date\n\t\t\t? { path: `${Prefix}${K}`; type: Date }\n\t\t\t: T[K] extends Array<infer U>\n\t\t\t\t? { path: `${Prefix}${K}`; type: Array<U> }\n\t\t\t\t: T[K] extends Record<infer _k, unknown>\n\t\t\t\t\t? DotPathMap<T[K], `${Prefix}${K}.`>\n\t\t\t\t\t: never;\n}[keyof T & string];\n\ntype PathRegistry<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> = DotPathMap<AuthContext<S, Resource, RequiresResource>>;\n\nexport type ValidConditionNode<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> = PathRegistry<S, Resource, RequiresResource> extends infer P extends {\n\tpath: string;\n\ttype: Primitive | Date | Array<infer _U>;\n}\n\t? {\n\t\t\t[K in P as K[\"path\"]]: {\n\t\t\t\tleft: K[\"path\"];\n\t\t\t\top: Operator;\n\t\t\t\tright:\n\t\t\t\t\t| K[\"type\"]\n\t\t\t\t\t| Exclude<Extract<P, { type: K[\"type\"] }>[\"path\"], K[\"path\"]>;\n\t\t\t};\n\t\t}[P[\"path\"]]\n\t: never;\n\nexport interface GroupNode<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> {\n\tjoin: \"and\" | \"or\";\n\tconditions: ConditionTree<S, Resource, RequiresResource>[];\n}\n\nexport type ConditionTree<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> =\n\t| ValidConditionNode<S, Resource, RequiresResource>\n\t| GroupNode<S, Resource, RequiresResource>;\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/entitlement.ts",
			"content": "import type { Policy } from \"@/registry/lib/auth/types/policy\";\nimport type { BaseResource } from \"@/registry/lib/auth/types/resource\";\nimport type { BaseSubject } from \"@/registry/lib/auth/types/subject\";\n\nexport type Entitlement<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tActions extends Readonly<string[]>,\n> = {\n\tid: number;\n\ttitle: string;\n\tdescription: string;\n\tresource: Resource[\"type\"];\n\tpolicies: {\n\t\t[A in Actions[number]]?:\n\t\t\t| Policy<S, Resource, true>\n\t\t\t| Policy<S, Resource, false>;\n\t};\n};\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/policy.ts",
			"content": "import type { ConditionTree } from \"@/registry/lib/auth/types/condition-tree\";\nimport type { BaseResource } from \"@/registry/lib/auth/types/resource\";\nimport type { BaseSubject } from \"@/registry/lib/auth/types/subject\";\n\nexport type AuthContext<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> = RequiresResource extends true\n\t? { subject: S; resource: Resource }\n\t: { subject: S };\n\nexport type Policy<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> = {\n\trequiresResource: RequiresResource;\n\tconditions: ConditionTree<S, Resource, RequiresResource>;\n};\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/resource.ts",
			"content": "export type BaseResource<T extends string> = {\n\ttype: T;\n\t[key: string]: unknown;\n};\nexport type BaseResourceMap<\n\tT extends { [K in keyof T]: BaseResource<K & string> },\n> = T;\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/subject.ts",
			"content": "export type BaseSubject = Record<string, unknown>;\n",
			"type": "registry:lib"
		}
	],
	"type": "registry:lib"
}
