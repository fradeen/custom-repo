{
	"$schema": "https://ui.shadcn.com/schema/registry-item.json",
	"name": "access-control",
	"title": "Attribute Based Access Control",
	"description": "Attribute based access controll system",
	"dependencies": ["json-rules-engine@7.3.1"],
	"files": [
		{
			"path": "src/registry/lib/auth/abac.ts",
			"content": "import { Engine } from \"json-rules-engine\";\nimport type { Condition } from \"@/registry/lib/auth/types/condition\";\nimport type { BaseResource } from \"@/registry/lib/auth/types/resource\";\nimport type { BaseSubject } from \"@/registry/lib/auth/types/subject\";\n\ntype AccessControlConfig<\n\tS extends BaseSubject,\n\tActions extends Readonly<Array<string>>,\n\tResourceMap extends { [K in keyof ResourceMap]: BaseResource<K & string> },\n> = {\n\tactions: Readonly<Array<string>>;\n\tgetConditions: (\n\t\tsubject: S,\n\t\tresource: ResourceMap[keyof ResourceMap][\"type\"],\n\t\taction: Actions[number],\n\t\tRequiresResource: boolean,\n\t) => Promise<Condition<S, ResourceMap[keyof ResourceMap], boolean>[]>;\n};\ntype ActionMethodMap<\n\tActions extends Readonly<Array<string>>,\n\tResourceMap extends { [K in keyof ResourceMap]: BaseResource<K & string> },\n> = {\n\t[A in Actions[number]]: (\n\t\targ:\n\t\t\t| ResourceMap[keyof ResourceMap]\n\t\t\t| ResourceMap[keyof ResourceMap][\"type\"],\n\t) => Promise<boolean>;\n};\nexport class AccessControl<\n\tS extends BaseSubject,\n\tActions extends Readonly<Array<string>>,\n\tResourceMap extends { [K in keyof ResourceMap]: BaseResource<K & string> },\n> {\n\t#config: AccessControlConfig<S, Actions, ResourceMap>;\n\tasync #checkAccess(\n\t\tsubject: S,\n\t\taction: Actions[number],\n\t\tresource:\n\t\t\t| ResourceMap[keyof ResourceMap]\n\t\t\t| ResourceMap[keyof ResourceMap][\"type\"],\n\t): Promise<boolean> {\n\t\ttry {\n\t\t\tconst resourceType =\n\t\t\t\ttypeof resource === \"string\" ? resource : resource.type;\n\t\t\tconst conditions = await this.#config.getConditions(\n\t\t\t\tsubject,\n\t\t\t\tresourceType,\n\t\t\t\taction,\n\t\t\t\t!(typeof resource === \"string\"),\n\t\t\t);\n\t\t\tif (!conditions.length)\n\t\t\t\tthrow new Error(\n\t\t\t\t\t\"No conditions/policies found for subject, resource/resource-type combo.\",\n\t\t\t\t);\n\t\t\tconst evalEngine = new Engine();\n\t\t\tevalEngine.addFact(\n\t\t\t\t\"context\",\n\t\t\t\ttypeof resource === \"string\"\n\t\t\t\t\t? { subject: subject }\n\t\t\t\t\t: {\n\t\t\t\t\t\t\tsubject: subject,\n\t\t\t\t\t\t\tresource: resource,\n\t\t\t\t\t\t},\n\t\t\t);\n\t\t\tfor (const condition of conditions) {\n\t\t\t\tevalEngine.removeRule(\"rule\");\n\t\t\t\tevalEngine.addRule({\n\t\t\t\t\tname: \"rule\",\n\t\t\t\t\tconditions: condition,\n\t\t\t\t\tevent: {\n\t\t\t\t\t\ttype: \"success\",\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t\tconst { events } = await evalEngine.run();\n\t\t\t\tif (events[0]) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t} catch (e) {\n\t\t\tconsole.error(e);\n\t\t\treturn false;\n\t\t}\n\t}\n\tconstructor(config: AccessControlConfig<S, Actions, ResourceMap>) {\n\t\tthis.#config = config;\n\t}\n\n\tcan(subject: S): {\n\t\t[A in Actions[number]]: (\n\t\t\targ:\n\t\t\t\t| ResourceMap[keyof ResourceMap]\n\t\t\t\t| ResourceMap[keyof ResourceMap][\"type\"],\n\t\t) => Promise<boolean>;\n\t} {\n\t\tconst api: ActionMethodMap<Actions, ResourceMap> = {} as ActionMethodMap<\n\t\t\tActions,\n\t\t\tResourceMap\n\t\t>;\n\n\t\tfor (const action of this.#config.actions) {\n\t\t\tapi[action as Actions[number]] = (arg) =>\n\t\t\t\tthis.#checkAccess(subject, action, arg);\n\t\t}\n\t\treturn Object.freeze(api);\n\t}\n}\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/condition.ts",
			"content": "import type { OperatorFor } from \"@/registry/lib/auth/types/operator\";\nimport type { AuthContext } from \"@/registry/lib/auth/types/policy\";\nimport type { BaseResource } from \"@/registry/lib/auth/types/resource\";\nimport type { BaseSubject } from \"@/registry/lib/auth/types/subject\";\n\ntype Primitive = string | boolean | number | bigint;\ntype Fact = \"context\";\n\ntype DotPathMap<T, Prefix extends string = \"\"> = {\n\t[K in keyof T & string]: T[K] extends Primitive\n\t\t? { path: `${Prefix}${K}`; type: T[K] }\n\t\t: T[K] extends Date\n\t\t\t? { path: `${Prefix}${K}`; type: Date }\n\t\t\t: T[K] extends Array<infer U>\n\t\t\t\t? { path: `${Prefix}${K}`; type: Array<U> }\n\t\t\t\t: T[K] extends Record<infer _k, unknown>\n\t\t\t\t\t? DotPathMap<T[K], `${Prefix}${K}.`>\n\t\t\t\t\t: never;\n}[keyof T & string];\n\ntype PathRegistry<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> = DotPathMap<AuthContext<S, Resource, RequiresResource>>;\n\nexport type ConditionNode<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> = PathRegistry<S, Resource, RequiresResource> extends infer P extends {\n\tpath: string;\n\ttype: Primitive | Date | Array<infer _U>;\n}\n\t? {\n\t\t\t[K in P as K[\"path\"]]: {\n\t\t\t\tfact: Fact;\n\t\t\t\tpath: `$.${K[\"path\"]}`;\n\t\t\t\toperator: OperatorFor<K[\"type\"]>;\n\t\t\t\tvalue:\n\t\t\t\t\t| K[\"type\"]\n\t\t\t\t\t| {\n\t\t\t\t\t\t\tfact: Fact;\n\t\t\t\t\t\t\tpath: `$.${Exclude<Extract<P, { type: K[\"type\"] }>[\"path\"], K[\"path\"]>}`;\n\t\t\t\t\t  };\n\t\t\t};\n\t\t}[P[\"path\"]]\n\t: never;\n\nexport type Condition<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> =\n\t| {\n\t\t\tkind: \"all\";\n\t\t\tall: (\n\t\t\t\t| ConditionNode<S, Resource, RequiresResource>\n\t\t\t\t| Condition<S, Resource, RequiresResource>\n\t\t\t)[];\n\t  }\n\t| {\n\t\t\tkind: \"any\";\n\t\t\tany: (\n\t\t\t\t| ConditionNode<S, Resource, RequiresResource>\n\t\t\t\t| Condition<S, Resource, RequiresResource>\n\t\t\t)[];\n\t  };\n\n// type Resource1 = { type: \"abc\"; extra: number };\n// type Resource2 = { type: \"cde\" };\n// type ResourceMap = BaseResourceMap<{\n// \tabc: Resource1;\n// \tcde: Resource2;\n// }>;\n// type Resource = ResourceMap[keyof ResourceMap];\n// type User = { id: number };\n// const ACTIONS = [\"create\", \"read\"] as const;\n// type Action = (typeof ACTIONS)[number];\n\n// const conditionNode: ConditionNode<User, ResourceMap[\"abc\"], true> = {\n// \tfact: \"context\",\n// \toperator: \"in\",\n// \tpath: \"$.subject.id\",\n// \tvalue: {\n// \t\tfact: \"context\",\n// \t\tpath: \"$.resource.extra\",\n// \t},\n// };\n\n// const condition: Condition<User, ResourceMap[\"abc\"], true> = {\n// \tkind: \"any\",\n// \tany: [\n// \t\tconditionNode,\n// \t\t{\n// \t\t\tfact: \"context\",\n// \t\t\toperator: \"equal\",\n// \t\t\tpath: \"$.subject.id\",\n// \t\t\tvalue: 1234,\n// \t\t},\n// \t\t{\n// \t\t\tkind: \"all\",\n// \t\t\tall: [conditionNode, conditionNode],\n// \t\t},\n// \t],\n// };\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/entitlement.ts",
			"content": "import type { Policy } from \"@/registry/lib/auth/types/policy\";\nimport type { BaseResource } from \"@/registry/lib/auth/types/resource\";\nimport type { BaseSubject } from \"@/registry/lib/auth/types/subject\";\n\nexport type Entitlement<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tActions extends Readonly<string[]>,\n> = {\n\tid: number;\n\ttitle: string;\n\tdescription: string;\n\tresource: Resource[\"type\"];\n\tpolicies: {\n\t\t[A in Actions[number]]?:\n\t\t\t| Policy<S, Resource, true>\n\t\t\t| Policy<S, Resource, false>;\n\t};\n};\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/operator.ts",
			"content": "type StringOperators =\n\t| \"equal\"\n\t| \"notEqual\"\n\t| \"contains\"\n\t| \"doesNotContain\"\n\t| \"startsWith\"\n\t| \"endsWith\";\n\ntype NumberOperators =\n\t| \"equal\"\n\t| \"notEqual\"\n\t| \"greaterThan\"\n\t| \"greaterThanInclusive\"\n\t| \"lessThan\"\n\t| \"lessThanInclusive\";\n\ntype BooleanOperators = \"equal\" | \"notEqual\";\n\ntype DateOperators =\n\t| \"equal\"\n\t| \"notEqual\"\n\t| \"greaterThan\"\n\t| \"greaterThanInclusive\"\n\t| \"lessThan\"\n\t| \"lessThanInclusive\"\n\t| \"before\"\n\t| \"after\";\n\ntype ArrayOperators =\n\t| \"equal\"\n\t| \"notEqual\"\n\t| \"lengthEqual\"\n\t| \"lengthNotEqual\"\n\t| \"lengthGreaterThan\"\n\t| \"lengthLessThan\";\n\nexport type OperatorFor<T> = T extends string\n\t? StringOperators\n\t: T extends number\n\t\t? NumberOperators\n\t\t: T extends bigint\n\t\t\t? NumberOperators\n\t\t\t: T extends boolean\n\t\t\t\t? BooleanOperators\n\t\t\t\t: T extends Date\n\t\t\t\t\t? DateOperators\n\t\t\t\t\t: T extends Array<unknown>\n\t\t\t\t\t\t? ArrayOperators\n\t\t\t\t\t\t: never;\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/policy.ts",
			"content": "import type { Condition } from \"@/registry/lib/auth/types/condition\";\nimport type { BaseResource } from \"@/registry/lib/auth/types/resource\";\nimport type { BaseSubject } from \"@/registry/lib/auth/types/subject\";\n\nexport type AuthContext<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> = RequiresResource extends true\n\t? { subject: S; resource: Resource }\n\t: { subject: S };\n\nexport type Policy<\n\tS extends BaseSubject,\n\tResource extends BaseResource<string>,\n\tRequiresResource extends boolean,\n> = {\n\trequiresResource: RequiresResource;\n\tconditions: Condition<S, Resource, RequiresResource>;\n};\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/resource.ts",
			"content": "export type BaseResource<T extends string> = {\n\ttype: T;\n\t[key: string]: unknown;\n};\nexport type BaseResourceMap<\n\tT extends { [K in keyof T]: BaseResource<K & string> },\n> = T;\nexport type WithType<K extends string, T> = T & { type: K };\n",
			"type": "registry:lib"
		},
		{
			"path": "src/registry/lib/auth/types/subject.ts",
			"content": "export type BaseSubject = Record<string, unknown>;\n",
			"type": "registry:lib"
		}
	],
	"type": "registry:lib"
}
